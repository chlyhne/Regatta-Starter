#!/usr/bin/env bash
set -euo pipefail

usage() {
  echo "Usage: $0 <file.ndjson|file.ndjson.gz|manifest.json|session-dir>" >&2
}

if [ $# -lt 1 ]; then
  usage
  exit 1
fi

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$script_dir"

src="$1"
if [ ! -f "$src" ]; then
  if [ -d "$src" ]; then
    if [ -f "$src/manifest.json" ]; then
      src="$src/manifest.json"
    else
      echo "manifest.json not found in: $src" >&2
      exit 1
    fi
  else
    echo "File not found: $src" >&2
    exit 1
  fi
fi

dest_dir="replay"
mkdir -p "$dest_dir"
base_override=""
tmp_file=""

if [[ "$src" == *.json ]]; then
  tmp_file="$(mktemp -t racetimer-replay-XXXX.ndjson)"
  base_override="$(python3 - "$src" "$tmp_file" <<'PY'
import gzip
import json
import os
import re
import sys

manifest_path = sys.argv[1]
out_path = sys.argv[2]

with open(manifest_path, "r", encoding="utf-8") as handle:
    manifest = json.load(handle)

chunks = manifest.get("chunks")
if not isinstance(chunks, list) or not chunks:
    raise SystemExit("Manifest has no chunks to assemble.")

def slug(value):
    return re.sub(r"[^a-z0-9]+", "-", str(value or "").lower()).strip("-")

device_id = slug(manifest.get("deviceId"))
session_id = slug(manifest.get("sessionId"))
base = None
if device_id and session_id:
    base = f"{device_id}-{session_id}.ndjson"
else:
    stem = os.path.splitext(os.path.basename(manifest_path))[0]
    base = f"{stem}.ndjson"

manifest_dir = os.path.dirname(os.path.abspath(manifest_path))

def resolve_path(key):
    if not key:
        return None
    key = os.path.normpath(key)
    if os.path.isabs(key) and os.path.exists(key):
        return key
    for depth in range(0, 6):
        candidate_root = manifest_dir
        for _ in range(depth):
            candidate_root = os.path.dirname(candidate_root)
        candidate = os.path.join(candidate_root, key)
        if os.path.exists(candidate):
            return candidate
    candidate = os.path.join(manifest_dir, key)
    if os.path.exists(candidate):
        return candidate
    return None

def copy_stream(source, out_handle):
    last_byte = None
    while True:
        chunk = source.read(1024 * 1024)
        if not chunk:
            break
        out_handle.write(chunk)
        last_byte = chunk[-1]
    return last_byte

def sort_key(entry):
    idx = entry.get("index")
    try:
        idx = int(idx)
    except Exception:
        idx = 0
    return (idx, entry.get("id") or "")

chunks_sorted = sorted(chunks, key=sort_key)

with open(out_path, "wb") as out_handle:
    for entry in chunks_sorted:
        key = entry.get("key") or entry.get("path") or entry.get("file")
        path = resolve_path(key)
        if not path:
            raise SystemExit(f"Chunk file not found for key: {key}")
        with open(path, "rb") as chunk_handle:
            head = chunk_handle.read(2)
            chunk_handle.seek(0)
            if head == b"\x1f\x8b":
                with gzip.GzipFile(fileobj=chunk_handle) as gz:
                    last = copy_stream(gz, out_handle)
            else:
                last = copy_stream(chunk_handle, out_handle)
        if last is not None and last != 0x0A:
            out_handle.write(b"\n")

print(base)
PY
)"
  if [ -z "$base_override" ]; then
    echo "Failed to assemble replay file from manifest." >&2
    rm -f "$tmp_file"
    exit 1
  fi
  src="$tmp_file"
  trap 'rm -f "$tmp_file"' EXIT
fi

replay_info="$(python3 - "$src" "$dest_dir" "$base_override" <<'PY'
import filecmp
import gzip
import json
import os
import sys

src = sys.argv[1]
dest_dir = sys.argv[2]
base_override = sys.argv[3] if len(sys.argv) > 3 else ""

MAX_RAW_BYTES = 20 * 1024 * 1024  # Keeps gzip outputs comfortably under 25 MB.

def stem_from_name(name):
    base = os.path.basename(name)
    if base.endswith(".gz"):
        base = base[:-3]
    if base.endswith(".ndjson"):
        base = base[:-7]
    return base

stem = stem_from_name(base_override or src)
if not stem:
    raise SystemExit("Could not derive replay file name.")

def is_gzip(path):
    try:
        with open(path, "rb") as handle:
            head = handle.read(2)
        return head == b"\x1f\x8b"
    except FileNotFoundError:
        return False

def line_iterator(path):
    if path.endswith(".gz") or is_gzip(path):
        with gzip.open(path, "rt", encoding="utf-8", errors="replace") as handle:
            for line in handle:
                yield line.rstrip("\n")
    else:
        with open(path, "rt", encoding="utf-8", errors="replace") as handle:
            for line in handle:
                yield line.rstrip("\n")

def write_gz(lines, dest_path):
    tmp_path = dest_path + ".tmp"
    with gzip.open(tmp_path, "wb", compresslevel=9) as gz:
        for line in lines:
            gz.write(line.encode("utf-8"))
            gz.write(b"\n")
    if os.path.exists(dest_path):
        if filecmp.cmp(tmp_path, dest_path, shallow=False):
            os.remove(tmp_path)
            return
        raise SystemExit(f"Replay file already exists: {dest_path} (different contents).")
    os.replace(tmp_path, dest_path)

files = []
buffer = []
buffer_bytes = [0]

def flush(part_index):
    if not buffer:
        return None
    filename = f"{stem}.part{part_index:03d}.ndjson.gz"
    dest_path = os.path.join(dest_dir, filename)
    write_gz(buffer, dest_path)
    buffer.clear()
    buffer_bytes[0] = 0
    return filename

part = 1
for line in line_iterator(src):
    line_bytes = len(line.encode("utf-8")) + 1
    if buffer and buffer_bytes[0] + line_bytes > MAX_RAW_BYTES:
        name = flush(part)
        if name:
            files.append(name)
            part += 1
    buffer.append(line)
    buffer_bytes[0] += line_bytes

name = flush(part)
if name:
    files.append(name)

if not files:
    raise SystemExit("No replay data found to write.")

if len(files) == 1:
    target = f"{stem}.ndjson.gz"
    if files[0] != target:
        src_path = os.path.join(dest_dir, files[0])
        dest_path = os.path.join(dest_dir, target)
        if os.path.exists(dest_path):
            if filecmp.cmp(src_path, dest_path, shallow=False):
                os.remove(src_path)
            else:
                raise SystemExit(f"Replay file already exists: {dest_path} (different contents).")
        else:
            os.replace(src_path, dest_path)
        files = [target]

print(json.dumps({"files": files, "label": stem}))
PY
)"

if [ -z "$replay_info" ]; then
  echo "Failed to package replay file." >&2
  exit 1
fi

REPLAY_INFO="$replay_info" python3 - <<'PY'
import json
import os
import re
import sys

manifest_path = os.path.join("replay", "manifest.json")
data = []
if os.path.exists(manifest_path):
    with open(manifest_path, "r", encoding="utf-8") as handle:
        try:
            data = json.load(handle)
        except json.JSONDecodeError as exc:
            raise SystemExit(f"Invalid JSON in {manifest_path}: {exc}") from exc

if not isinstance(data, list):
    raise SystemExit(f"{manifest_path} must contain a JSON array.")

info = json.loads(os.environ.get("REPLAY_INFO", "{}"))
files = info.get("files") or []
label = info.get("label") or ""
if not files or not label:
    raise SystemExit("Missing replay file metadata")

if len(files) == 1:
    if any(isinstance(entry, dict) and entry.get("path") == files[0] for entry in data):
        print(f"Manifest already contains {files[0]}")
        sys.exit(0)
else:
    for entry in data:
        if not isinstance(entry, dict):
            continue
        if entry.get("chunks") == files:
            print("Manifest already contains replay chunks.")
            sys.exit(0)

slug = re.sub(r"[^a-z0-9]+", "-", label.lower()).strip("-")
if not slug:
    slug = "replay"
existing = {entry.get("id") for entry in data if isinstance(entry, dict)}
candidate = slug
suffix = 2
while candidate in existing:
    candidate = f"{slug}-{suffix}"
    suffix += 1

if len(files) == 1:
    entry = {"id": candidate, "label": label, "path": files[0]}
else:
    entry = {"id": candidate, "label": label, "chunks": files}
data.append(entry)

with open(manifest_path, "w", encoding="utf-8") as handle:
    json.dump(data, handle, indent=2)
    handle.write("\n")
PY

REPLAY_INFO="$replay_info" python3 - <<'PY'
import json
import os
import re

sw_path = "sw.js"
info = json.loads(os.environ.get("REPLAY_INFO", "{}"))
files = info.get("files") or []
if not files:
    raise SystemExit("Missing replay files list.")

with open(sw_path, "r", encoding="utf-8") as handle:
    text = handle.read()

match = re.search(r'CACHE_NAME\s*=\s*["\']racetimer-v(\d+)["\']', text)
if not match:
    raise SystemExit("CACHE_NAME not found in sw.js")
current = int(match.group(1))
text = re.sub(
    r'const\s+CACHE_NAME\s*=\s*"racetimer-v\d+"',
    f'const CACHE_NAME = "racetimer-v{current + 1}"',
    text,
    count=1,
)

start = text.find("const ASSETS = [")
if start < 0:
    raise SystemExit("ASSETS array not found in sw.js")
end = text.find("];", start)
if end < 0:
    raise SystemExit("ASSETS array closing not found in sw.js")

for file_name in files:
    asset_line = f'  "./replay/{os.path.basename(file_name)}",'
    if asset_line not in text:
        text = text[:end] + asset_line + "\n" + text[end:]
        end += len(asset_line) + 1

with open(sw_path, "w", encoding="utf-8") as handle:
    handle.write(text)
PY

echo "Added replay files:"
python3 - <<'PY'
import json
import os

info = json.loads(os.environ.get("REPLAY_INFO", "{}"))
for name in info.get("files") or []:
    print(f"  replay/{os.path.basename(name)}")
PY
echo "Updated replay/manifest.json and sw.js"

REPLAY_INFO="$replay_info" python3 - <<'PY'
import json
import os

info = json.loads(os.environ.get("REPLAY_INFO", "{}"))
for name in info.get("files") or []:
    path = os.path.join("replay", os.path.basename(name))
    if os.path.exists(path):
        os.system(f'git add "{path}" >/dev/null 2>&1')
PY
git add replay/manifest.json sw.js >/dev/null 2>&1 || true
