#!/usr/bin/env bash
set -euo pipefail

usage() {
  echo "Usage: $0 <file.ndjson|file.ndjson.gz|manifest.json|session-dir>" >&2
}

if [ $# -lt 1 ]; then
  usage
  exit 1
fi

src="$1"
if [ ! -f "$src" ]; then
  if [ -d "$src" ]; then
    if [ -f "$src/manifest.json" ]; then
      src="$src/manifest.json"
    else
      echo "manifest.json not found in: $src" >&2
      exit 1
    fi
  else
    echo "File not found: $src" >&2
    exit 1
  fi
fi

dest_dir="replay"
mkdir -p "$dest_dir"
base_override=""
tmp_file=""

if [[ "$src" == *.json ]]; then
  tmp_file="$(mktemp -t racetimer-replay-XXXX.ndjson)"
  base_override="$(python3 - "$src" "$tmp_file" <<'PY'
import gzip
import json
import os
import re
import sys

manifest_path = sys.argv[1]
out_path = sys.argv[2]

with open(manifest_path, "r", encoding="utf-8") as handle:
    manifest = json.load(handle)

chunks = manifest.get("chunks")
if not isinstance(chunks, list) or not chunks:
    raise SystemExit("Manifest has no chunks to assemble.")

def slug(value):
    return re.sub(r"[^a-z0-9]+", "-", str(value or "").lower()).strip("-")

device_id = slug(manifest.get("deviceId"))
session_id = slug(manifest.get("sessionId"))
base = None
if device_id and session_id:
    base = f"{device_id}-{session_id}.ndjson"
else:
    stem = os.path.splitext(os.path.basename(manifest_path))[0]
    base = f"{stem}.ndjson"

manifest_dir = os.path.dirname(os.path.abspath(manifest_path))

def resolve_path(key):
    if not key:
        return None
    key = os.path.normpath(key)
    if os.path.isabs(key) and os.path.exists(key):
        return key
    for depth in range(0, 6):
        candidate_root = manifest_dir
        for _ in range(depth):
            candidate_root = os.path.dirname(candidate_root)
        candidate = os.path.join(candidate_root, key)
        if os.path.exists(candidate):
            return candidate
    candidate = os.path.join(manifest_dir, key)
    if os.path.exists(candidate):
        return candidate
    return None

def copy_stream(source, out_handle):
    last_byte = None
    while True:
        chunk = source.read(1024 * 1024)
        if not chunk:
            break
        out_handle.write(chunk)
        last_byte = chunk[-1]
    return last_byte

def sort_key(entry):
    idx = entry.get("index")
    try:
        idx = int(idx)
    except Exception:
        idx = 0
    return (idx, entry.get("id") or "")

chunks_sorted = sorted(chunks, key=sort_key)

with open(out_path, "wb") as out_handle:
    for entry in chunks_sorted:
        key = entry.get("key") or entry.get("path") or entry.get("file")
        path = resolve_path(key)
        if not path:
            raise SystemExit(f"Chunk file not found for key: {key}")
        with open(path, "rb") as chunk_handle:
            head = chunk_handle.read(2)
            chunk_handle.seek(0)
            if head == b"\x1f\x8b":
                with gzip.GzipFile(fileobj=chunk_handle) as gz:
                    last = copy_stream(gz, out_handle)
            else:
                last = copy_stream(chunk_handle, out_handle)
        if last is not None and last != 0x0A:
            out_handle.write(b"\n")

print(base)
PY
)"
  if [ -z "$base_override" ]; then
    echo "Failed to assemble replay file from manifest." >&2
    rm -f "$tmp_file"
    exit 1
  fi
  src="$tmp_file"
  trap 'rm -f "$tmp_file"' EXIT
fi

base="${base_override:-$(basename "$src")}"
dest="$dest_dir/$base"

if [ "$src" != "$dest" ]; then
  if [ -e "$dest" ]; then
    if cmp -s "$src" "$dest"; then
      echo "Replay file already exists: $dest (same contents)." >&2
    else
      echo "Replay file already exists: $dest (different contents)." >&2
      exit 1
    fi
  else
    cp "$src" "$dest"
  fi
fi

python3 - "$base" <<'PY'
import json
import os
import re
import sys

manifest_path = os.path.join("replay", "manifest.json")
data = []
if os.path.exists(manifest_path):
    with open(manifest_path, "r", encoding="utf-8") as handle:
        try:
            data = json.load(handle)
        except json.JSONDecodeError as exc:
            raise SystemExit(f"Invalid JSON in {manifest_path}: {exc}") from exc

if not isinstance(data, list):
    raise SystemExit(f"{manifest_path} must contain a JSON array.")

file_name = os.path.basename(sys.argv[1]) if len(sys.argv) > 1 else ""
if not file_name:
    raise SystemExit("Missing replay file name")

if any(isinstance(entry, dict) and entry.get("path") == file_name for entry in data):
    print(f"Manifest already contains {file_name}")
    sys.exit(0)

label = os.path.splitext(file_name)[0]
slug = re.sub(r"[^a-z0-9]+", "-", label.lower()).strip("-")
if not slug:
    slug = "replay"
existing = {entry.get("id") for entry in data if isinstance(entry, dict)}
candidate = slug
suffix = 2
while candidate in existing:
    candidate = f"{slug}-{suffix}"
    suffix += 1

entry = {"id": candidate, "label": label, "path": file_name}
data.append(entry)

with open(manifest_path, "w", encoding="utf-8") as handle:
    json.dump(data, handle, indent=2)
    handle.write("\n")
PY

REPLAY_FILE="$base" python3 - <<'PY'
import os
import re

sw_path = "sw.js"
with open(sw_path, "r", encoding="utf-8") as handle:
    text = handle.read()

match = re.search(r'const\s+CACHE_NAME\s*=\s*"racetimer-v(\d+)"', text)
if not match:
    raise SystemExit("CACHE_NAME not found in sw.js")
current = int(match.group(1))
text = re.sub(
    r'const\s+CACHE_NAME\s*=\s*"racetimer-v\d+"',
    f'const CACHE_NAME = "racetimer-v{current + 1}"',
    text,
    count=1,
)

file_name = os.path.basename(os.environ.get("REPLAY_FILE", ""))
if not file_name:
    raise SystemExit("Missing REPLAY_FILE")

asset_line = f'  "./replay/{file_name}",'
if asset_line not in text:
    start = text.find("const ASSETS = [")
    if start < 0:
        raise SystemExit("ASSETS array not found in sw.js")
    end = text.find("];", start)
    if end < 0:
        raise SystemExit("ASSETS array closing not found in sw.js")
    text = text[:end] + asset_line + "\n" + text[end:]

with open(sw_path, "w", encoding="utf-8") as handle:
    handle.write(text)
PY

echo "Added replay file: $dest"
echo "Updated replay/manifest.json and sw.js"

git add "replay/$base" replay/manifest.json sw.js >/dev/null 2>&1 || true
