
% !TeX root = master.tex

\hypertarget{speed-and-heading-estimation}{%
\section{Speed and Heading Estimation}\label{speed-and-heading-estimation}}

RaceStarter (and RacePerformance) both depend on detecting small changes in position, speed, and
heading. On a real boat those quantities have dynamics: you accelerate and decelerate,
you turn, you are pushed around by waves and gusts, and you make steering corrections.
That means a good estimator should not treat each sensor sample as an independent truth.

At the same time, the sensors available in a phone browser are not ideal. GPS fixes are
noisy, and if you compute speed and heading from successive positions you amplify that
noise. At low speed, GPS course can be unstable or missing altogether. The IMU helps with
fast heading changes (gyro) and can provide acceleration cues, but it drifts and the axis
conventions vary across devices.

Near a start line, these weaknesses show up immediately: the distance-to-line can jitter
by multiple meters, the projected track can wobble, and the UI becomes stressful because
the numbers do not feel ``trustworthy''. The rest of the app is built on the assumption
that the numbers are stable enough that the user can focus on sailing, not on filtering in
their head.

The estimation approach in RaceStarter therefore combines a simple motion model (boats do
not teleport; velocity changes smoothly) with noisy measurements (GPS tells us where we
are, but with uncertainty). We use a Kalman filter to turn jittery GPS into a steady 2D
position and velocity vector, and we optionally use the gyro to update heading changes
between GPS fixes. The filter is not trying to be universally optimal; it is tuned for the
operational goal of giving stable, usable numbers in a high-stress situation.

\subsection{Movement model}

This subsection defines the state vector and the motion model used between GPS fixes,
including the optional turning update when IMU assist is enabled.

We estimate both position and velocity in 2D:
\begin{flalign}
\hspace{5em}x &= [p_x, p_y, v_x, v_y]^T && \left[\text{m}, \text{m/s}\right] \label{eq:rs:state}
\end{flalign}
In \eqref{eq:rs:state}, \(p_x\) and \(p_y\) are positions in meters and \(v_x\) and
\(v_y\) are velocities in meters/second.

This state definition matters operationally: it lets the app produce a steady velocity
vector even when GPS does not provide a reliable heading/speed (e.g.\ very low speed, or a
device/browser that omits those fields).

Between GPS updates, we assume the boat maintains constant velocity over
a short interval \(dt\). That is:

\begin{flalign}
\hspace{5em}p_{x,k} &= p_{x,k-1} + v_{x,k-1}\,dt && \left[\text{m}\right] \label{eq:rs:cv-px} \\
\hspace{5em}p_{y,k} &= p_{y,k-1} + v_{y,k-1}\,dt && \left[\text{m}\right] \label{eq:rs:cv-py} \\
\hspace{5em}v_{x,k} &= v_{x,k-1} && \left[\text{m/s}\right] \label{eq:rs:cv-vx} \\
\hspace{5em}v_{y,k} &= v_{y,k-1} && \left[\text{m/s}\right] \label{eq:rs:cv-vy}
\end{flalign}
In \eqref{eq:rs:cv-px} and \eqref{eq:rs:cv-py}, \(dt\) is the elapsed time between
prediction steps and position components are in meters. In \eqref{eq:rs:cv-vx} and
\eqref{eq:rs:cv-vy}, the velocity components are in meters/second.

In matrix form:

\begin{flalign}
\hspace{5em}x_k &= F x_{k-1} + w && \left[\text{m}, \text{m/s}\right] \label{eq:rs:state-update}
\end{flalign}
In \eqref{eq:rs:state-update}, \(F\) is the state transition matrix and \(w\) is the
process noise term.

with

\begin{flalign}
\hspace{5em}F &=
\begin{bmatrix}
1 & 0 & dt & 0 \\
0 & 1 & 0 & dt \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
&& \left[\text{mixed}\right] \label{eq:rs:F}
\end{flalign}
In \eqref{eq:rs:F}, the \(dt\) entries carry seconds and the rest are unitless, so the
matrix has mixed units.

The term \texttt{w} is ``everything the model does not capture'':
acceleration, turning, waves, gusts, steering corrections, and also
model mismatch.

That is what process noise is for.

Turning update (optional, IMU-assisted). The basic CV model above
assumes the velocity vector is constant between updates. When IMU assist is
enabled, we add one extra deterministic step between GPS fixes. Conceptually we integrate
the yaw rate into a heading change \(\Delta\psi\), update a stored heading estimate
\(\text{headingRad}\), rotate the velocity vector \([v_x, v_y]\) by \(\Delta\psi\), and
rotate the covariance so \texttt{P} stays consistent.

This is effectively a coordinated-turn assumption: heading changes
redirect the velocity vector while preserving its magnitude and without
introducing sideways speed. For sailboats this is a reasonable first-order
model (the keel resists sideslip), even if reality is not perfectly lossless.

Once we choose that deterministic rotation, the covariance must
rotate with it. \(P\) is the covariance of the current state vector; if the
state is rotated by a matrix \(A\), the correct covariance is
\(P' = A P A^T\). Here \(P'\) means the \emph{updated} covariance after the
rotation (not a time derivative). We then \emph{replace} the filter's stored
covariance with \(P'\) so that every subsequent predict/update step uses the
rotated uncertainty. In other words, \(P'\) becomes the new \(P\) used in the
next \(P^- = F P F^T + Q\) and in the next Kalman update. Not rotating \(P\)
would leave the filter internally inconsistent (uncertainty still aligned to
the old velocity direction).

Rotation is applied only to the \emph{velocity components} of the state:
position stays in the world frame, but velocity is rotated to track the boat's
heading. In matrix form, the state rotation is:

\begin{flalign}
\hspace{5em}A &=
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & \cos\Delta\psi & -\sin\Delta\psi \\
0 & 0 & \sin\Delta\psi & \cos\Delta\psi
\end{bmatrix}
&& \left[1\right] \label{eq:rs:rotation}
\end{flalign}
In \eqref{eq:rs:rotation}, \(\Delta\psi\) is the integrated yaw change and \(A\) is a
dimensionless rotation matrix applied to the velocity components.

Applying \(P' = A P A^T\) with this block-rotation preserves the position
covariances in the global frame while keeping the velocity uncertainty aligned
with the updated heading (including the position/velocity cross terms).

There is also a real-world constraint: the device is fixed to the boat, so the
IMU is measuring actual hull rotation, and the boat's own inertia
acts as a physical low-pass. That helps keep the yaw updates grounded. We
still avoid unphysical instantaneous spins by clamping IMU dt and blending GPS
heading over time.

This turning step does not add a new measurement update; it is a deterministic
update between GPS fixes. The measurement noise \texttt{R} is unchanged.

\subsection{Noise model (process and measurement)}

This subsection describes the process noise (\(Q\)) and measurement noise (\(R\)), and how
the parameters map to expected boat dynamics and GPS quality.

Interpretation of \(q\). We use a standard ``nearly constant velocity'' (CV) model where
acceleration is modeled as continuous white noise. In that model, \(q\) is the
\textbf{acceleration variance} (units \((\mathrm{m/s^2})^2\)). Increasing \(q\) means we
expect larger unmodeled accelerations (gusts, steering changes, wave impacts), and the
filter should therefore be more willing to change its velocity estimate quickly. A useful
mental model is: \(q\) controls how ``twitchy'' the boat is allowed to be between GPS
fixes.

Discrete-time \(Q\) matrix. For one axis (say \(x\)), with state
\([p, v]^T\), constant velocity model, and white acceleration noise, the
discrete-time process noise covariance becomes:

\begin{flalign}
\hspace{5em}Q_{\text{axis}} &= q
\begin{bmatrix}
dt^4/4 & dt^3/2 \\
dt^3/2 & dt^2
\end{bmatrix}
&& \left[\text{mixed}\right] \label{eq:rs:q-axis}
\end{flalign}
In \eqref{eq:rs:q-axis}, \(q\) is the acceleration variance and the \(dt\) powers set the
position and velocity covariance scalings, which produces mixed units across the matrix.

Why those powers of \(dt\)? Position is the integral of velocity, velocity is the integral
of acceleration, and integrating white noise introduces these characteristic time scalings.

If we assumed identical behavior in every direction, the full 2D filter
would be two independent copies (\(x\) and \(y\)), combined into
\(4\times4\) form:
\begin{flalign}
\hspace{5em}Q &=
\begin{bmatrix}
q\,dt^4/4 & 0 & q\,dt^3/2 & 0 \\
0 & q\,dt^4/4 & 0 & q\,dt^3/2 \\
q\,dt^3/2 & 0 & q\,dt^2 & 0 \\
0 & q\,dt^3/2 & 0 & q\,dt^2
\end{bmatrix}
&& \left[\text{mixed}\right] \label{eq:rs:Q}
\end{flalign}
In \eqref{eq:rs:Q}, the full process noise covariance retains the same mixed units as
\eqref{eq:rs:q-axis}, now arranged for the 2D state.

In RaceStarter we make a more boat-like assumption: forward and sideways
acceleration are not equally likely.

The important modeling choice is that a boat can change speed much more easily along its
heading than sideways. In other words, acceleration uncertainty is anisotropic: forward
acceleration variance should be higher (speed changes are common), while lateral variance
should be much lower (boats do not slide sideways nearly as much).

We encode that by building an anisotropic \texttt{Q} in a local frame aligned
with the current heading: a forward acceleration variance \(q_f\) and a
smaller lateral variance \(q_l\). We then rotate that covariance into the
global x/y frame so the model stays aligned with the boat's direction of
travel even as it turns.

The matrix is still symmetric and uses the same CV structure, but it now
contains off-diagonal terms because the ``forward'' axis is not aligned
with the global x/y axes.

Debug visualization. In the debug view we draw the position block of \texttt{Q} so this
anisotropy is obvious. The overlay is anchored to the device position (the Kalman state is
the device), rotated by the current velocity heading (which changes with GPS or IMU
turning updates), and scaled to a fixed display length so it communicates orientation
rather than magnitude.

GPS provides a measurement of position:

\begin{flalign}
\hspace{5em}z &= [p_x, p_y]^T && \left[\text{m}\right] \label{eq:rs:z}
\end{flalign}
In \eqref{eq:rs:z}, \(z\) is the measured position in meters.

and we use:

\begin{flalign}
\hspace{5em}z_k &= H x_k + v && \left[\text{m}\right] \label{eq:rs:measurement}
\end{flalign}
In \eqref{eq:rs:measurement}, \(v\) is the measurement noise term with the same units as
position.

with

\begin{flalign}
\hspace{5em}H &=
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0
\end{bmatrix}
&& \left[1\right] \label{eq:rs:H}
\end{flalign}
In \eqref{eq:rs:H}, the measurement matrix selects the position components of the state.

The measurement noise \texttt{v} has covariance \texttt{R}.

Choosing \(R\) from GPS accuracy. Browsers provide
\texttt{position.coords.accuracy} in meters. It is (roughly) a
\(1\sigma\) radius. We make a simple, explicit assumption:

we treat the uncertainty as isotropic (same in x and y) and uncorrelated between axes.
With that, we use:

\begin{flalign}
\hspace{5em}r &= \text{accuracy}^2 && \left[\mathrm{m^2}\right] \label{eq:rs:r}
\end{flalign}
In \eqref{eq:rs:r}, \(\text{accuracy}\) is the reported 1\(\sigma\) position radius in
meters and \(r\) is its variance.
\begin{flalign}
\hspace{5em}R &= r I_2 && \left[\mathrm{m^2}\right] \label{eq:rs:R}
\end{flalign}
In \eqref{eq:rs:R}, \(R\) is the isotropic measurement covariance.

We clamp the reported accuracy because sometimes devices report absurd
values:

\begin{flalign}
\hspace{5em}\text{accuracy} &= \text{clamp}(\text{reportedAccuracy}, \text{min}, \text{max}) && \left[\text{m}\right] \label{eq:rs:accuracy-clamp}
\end{flalign}
In \eqref{eq:rs:accuracy-clamp}, \(\text{reportedAccuracy}\) is the raw GPS accuracy and
the clamp bounds are the configured minimum and maximum in meters.

This prevents one bad fix from causing a huge gain swing.

What this means for the Kalman gain:
good GPS (small accuracy) implies small \(R\), which increases the gain and makes the
filter follow measurements more. Bad GPS (large accuracy) implies large \(R\), which
reduces the gain so the filter trusts the motion model more and the output does not jump
around.

\hypertarget{the-kalman-filter-equations-what-happens-each-gps-update}{%
\subsection{The Kalman filter equations (what happens each GPS
update)}\label{the-kalman-filter-equations-what-happens-each-gps-update}}

This subsection walks through the predict/update steps used when a GPS fix arrives. The
filter maintains a state estimate \texttt{x} and a covariance estimate \texttt{P}.

Each new GPS fix performs:

Predict step:

\begin{flalign}
\hspace{5em}x^- &= F x && \left[\text{m}, \text{m/s}\right] \label{eq:rs:predict-x}
\end{flalign}
In \eqref{eq:rs:predict-x}, \(x^-\) is the predicted state before the measurement update.

\begin{flalign}
\hspace{5em}P^- &= F P F^T + Q && \left[\text{mixed}\right] \label{eq:rs:predict-P}
\end{flalign}
In \eqref{eq:rs:predict-P}, \(P^-\) is the predicted covariance and \(Q\) is the process
noise covariance.

Update step:

Innovation covariance:

\begin{flalign}
\hspace{5em}S &= H P^- H^T + R && \left[\mathrm{m^2}\right] \label{eq:rs:S}
\end{flalign}
In \eqref{eq:rs:S}, \(S\) is the innovation covariance in measurement space.

Gain:

\begin{flalign}
\hspace{5em}K &= P^- H^T S^{-1} && \left[\text{mixed}\right] \label{eq:rs:K}
\end{flalign}
In \eqref{eq:rs:K}, \(K\) is the Kalman gain that maps measurement residuals into state
corrections.

Innovation:

\begin{flalign}
\hspace{5em}y &= z - H x^- && \left[\text{m}\right] \label{eq:rs:y}
\end{flalign}
In \eqref{eq:rs:y}, \(y\) is the measurement residual.

State update:

\begin{flalign}
\hspace{5em}x &= x^- + K y && \left[\text{m}, \text{m/s}\right] \label{eq:rs:update-x}
\end{flalign}
In \eqref{eq:rs:update-x}, the predicted state is corrected by the innovation.

Covariance update:

\begin{flalign}
\hspace{5em}P &= P^- - K (H P^-) && \left[\text{mixed}\right] \label{eq:rs:update-P}
\end{flalign}
In \eqref{eq:rs:update-P}, the covariance is reduced based on the measurement update.

The code implements these explicitly (no external matrix library) because the matrices are
tiny (\(4\times4\), \(2\times2\)) and the app is intended to remain a static PWA with
minimal dependencies.

\hypertarget{predict-only-updates-at-5-hz-between-fixes}{%
\subsection{Predict-only updates at 5 Hz (between
fixes)}\label{predict-only-updates-at-5-hz-between-fixes}}

GPS does not arrive at a fixed rate. The app still needs a stable,
smooth estimate for race view, debug view, and GPS marking. To get that,
we run the predict step on a fixed timer (about 5 Hz) whenever
a filter state exists.

In practice this means the state is advanced every \(\approx 200\,\mathrm{ms}\) using the
motion model and the \textbf{elapsed time} since the last predict tick. These ticks are
predict-only, so there is no measurement update and \(R\) is unchanged. When a real GPS fix
arrives, we perform the normal measurement update at the current filter time. If the fix
timestamp is older than the current filter time, we treat it as arriving ``now'' so the
filter time stays monotonic. Large time gaps are capped (the max dt clamp still applies),
so a single pause does not explode the covariance.

This gives the same filter behavior as a classic predict-update loop,
but with a smoother output cadence that does not depend on GPS jitter.

Relevant code is \texttt{predictKalmanState()} in \texttt{kalman.js} (predict-only step)
and the 5 Hz loop in \texttt{app.js} that keeps the estimate moving.

\hypertarget{imu-assisted-heading-optional-racedebug-toggle}{%
\subsection{IMU-assisted heading (optional, race/debug
toggle)}\label{imu-assisted-heading-optional-racedebug-toggle}}

The GPS-derived heading can be slow or unstable, especially at low
speed. When IMU assist is enabled, we use the gyroscope's yaw rate to
update the heading estimate between GPS fixes, while still letting GPS
gently correct long-term drift.

Estimating the down axis. The gyroscope reports rotation rates about
the device's axes, but we need the component of rotation about the vertical
(down) axis to get yaw. Because the device can move in waves, we estimate down
on every motion event. Concretely, we read \texttt{accelerationIncludingGravity}; if
\texttt{acceleration} is available we subtract it to remove fast linear motion
(\(g \approx a_{\text{incl}} - a_{\text{lin}}\)); and we low-pass the result so the down
estimate changes smoothly instead of reacting to every wave.

The low-pass factor is configured in \texttt{docs/tuning.tex} along with
the other tuning constants. This section focuses on how the estimate is
used once tuned.

Yaw rate from the gyro. The device supplies rotation rates around its
own axes. We project that rotation vector onto the estimated gravity direction:

\begin{flalign}
\hspace{5em}\text{yawRate} &\approx - (\omega \cdot \hat{g}) && \left[\text{rad/s}\right] \label{eq:rs:yawrate}
\end{flalign}
In \eqref{eq:rs:yawrate}, \(\omega\) is the gyro rotation vector and \(\hat{g}\) is the
unit gravity direction.

This gives an estimated rotation rate about down. The sign is chosen so
a right turn increases heading in the race/debug view.

Axis mapping sanity check. On iOS (screen up, flat on a table) the
observed mapping is that \(\alpha\) responds to pitch (lift top edge up/down), \(\beta\)
responds to roll (lift left edge up/down), and \(\gamma\) responds to yaw (rotate flat on
the table).

We map these to the internal rotation vector as \(\omega_x = \alpha\), \(\omega_y = \beta\),
and \(\omega_z = \gamma\).

The gravity projection then extracts the yaw component robustly even
when the device is not perfectly level.

To confirm this on-device, the Debug panel shows \texttt{IMU rot} (alpha/beta/gamma in
deg/s) and \texttt{IMU yaw} (computed yaw rate and the current gravity vector).

These readouts make it clear if pitch/roll are leaking into yaw and
whether axis mapping needs to be revisited.

Applying yaw to the filter. The yaw rate is integrated to a heading
change and applied through the turning update described in the movement model
(rotate the velocity state and covariance so the filter stays internally
consistent). This is a deterministic update between GPS fixes; \(R\) is
unchanged.

Blending GPS and IMU heading. When GPS speed is above a minimum
threshold, we compute a GPS heading from the Kalman velocity. If IMU is
enabled, GPS nudges the IMU heading with a tunable weight. If IMU is disabled,
GPS heading is used directly. Tuning details live in \texttt{docs/tuning.tex}.

Calibration workflow (per device). Different devices report gyro axes
differently. To avoid hard-coded per-device mappings, RaceStarter uses a simple
on-device calibration. You open \textbf{Settings -> IMU calibration}, place the device
flat (screen up), and rotate it clockwise for a few seconds. This produces a short
sequence where the intended yaw axis is clearly excited.

The app selects the axis mapping that best aligns the rotation vector
with gravity during that yaw motion and stores it in settings. IMU
assist is blocked until calibration is done.

Calibration also checks for real motion: it requires enough rotation
samples and a consistently positive yaw rate (clockwise). If you do not
rotate the device, calibration fails with an error and the IMU remains
disabled.

\hypertarget{marking-the-start-line-with-gps-no-bow-offset}{%
\subsection{Marking the start line with GPS (no bow
offset)}\label{marking-the-start-line-with-gps-no-bow-offset}}

When you press ``Set port mark (GPS)'' or ``Set starboard mark (GPS)'',
the app stores the latest Kalman position estimate for the device. We
deliberately do not apply the bow offset here. Operationally the user lines up the
\textbf{device} with the physical mark, so the most honest reference is the device
position itself. The mark is therefore captured immediately from the current estimate
(no averaging, no waiting for future fixes).

Because the Kalman estimate updates at 5 Hz between fixes, the
``latest'' position is a smooth, up-to-date estimate even if GPS
delivers at a slower rate.

\hypertarget{bow-offset-how-it-is-applied-in-race-projections}{%
\subsection{Bow offset: how it is applied in race
projections}\label{bow-offset-how-it-is-applied-in-race-projections}}

The Kalman filter estimates the device position and velocity. The boat
bow is then constructed by shifting the device position forward along the
velocity vector by the user's bow offset.

Race view uses two projections, and the bow offset is handled
differently in each. In the \emph{At current heading} projection, we already have the bow
position (device + forward offset), and we simply project that bow point along the current
velocity vector to the start time. In the \emph{Towards line} projection, we assume you
will steer straight toward the closest point on the line, so we back out the \textbf{device
position} from the bow, compute the perpendicular direction to the line, and then re-apply
the bow offset \textbf{along that direction} (not along the current velocity).

This keeps the geometry consistent for each assumption.

\hypertarget{where-to-look-in-the-repo}{%
\subsection{Where to look in the
repo}\label{where-to-look-in-the-repo}}

This subsection lists the main source files for the estimation and supporting logic.
The core filter is implemented in \texttt{kalman.js}. The gain scheduling rules are
documented in \texttt{docs/tuning.tex} and the values live in \texttt{tuning.js}. The speed
history used for scheduling is \texttt{state.speedHistory} maintained in \texttt{app.js}.
The debug process-noise visualization lives in \texttt{track.js}.
